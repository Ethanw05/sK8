// PSG <-> DDS WinForms tool with preview & "Invert Alpha (preview only)"
// Ethan-special: ground-truth DDS/Arena logic ported from your C++ snippets without changing parsing semantics.
// .NET 6 / WinForms. No external packages.
// Tip: Put this in Program.cs of a new WinForms project, set <Platforms>x64</Platforms> if desired.

using System;
using System.Buffers.Binary;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

namespace PsgDdsTool
{
    internal static class Program
    {
        [STAThread]
        static void Main()
        {
            
            Application.Run(new MainForm());
        }
    }

    public sealed class MainForm : Form
    {
        private Button btnOpenPsg;
        private Button btnExportSelectedDDS;
        private Button btnExportAllDDS;
        private Button btnInjectDDS;
        private Button btnSaveAsPSG; // optional: save a copy after inject
        private ListView lvTextures;
        private PictureBox pbPreview;
        private CheckBox cbInvertAlpha;
        private Label lblInfo;
        private OpenFileDialog ofd;
        private SaveFileDialog sfd;
        private OpenFileDialog ofdDDS;

        private PsgFile currentPsg;
        private PsgTextureEntry currentTextureSelection;
        private byte[] currentPreviewDDS;

        public MainForm()
        {
            Text = "PSG <-> DDS Converter + Preview (Invert Alpha is VIEW ONLY)";
            Width = 1250;
            Height = 800;

            btnOpenPsg = new Button { Text = "Open PSG/RG2/RX2...", Left = 10, Top = 10, Width = 180 };
            btnExportSelectedDDS = new Button { Text = "Export Selected DDS", Left = 200, Top = 10, Width = 180 };
            btnExportAllDDS = new Button { Text = "Export All DDS", Left = 390, Top = 10, Width = 150 };
            btnInjectDDS = new Button { Text = "Inject DDS into PSG (in-place)", Left = 550, Top = 10, Width = 230 };
            btnSaveAsPSG = new Button { Text = "Save PSG As...", Left = 790, Top = 10, Width = 150 };

            lvTextures = new ListView
            {
                Left = 10,
                Top = 45,
                Width = 600,
                Height = ClientSize.Height - 60,
                View = View.Details,
                FullRowSelect = true,
                MultiSelect = false,
                Anchor = AnchorStyles.Left | AnchorStyles.Top | AnchorStyles.Bottom
            };
            lvTextures.Columns.Add("Index", 60);
            lvTextures.Columns.Add("Name", 240);
            lvTextures.Columns.Add("Platform", 80);
            lvTextures.Columns.Add("Dim", 80);
            lvTextures.Columns.Add("WxH", 120);
            lvTextures.Columns.Add("Mips", 60);
            lvTextures.Columns.Add("Format", 140);

            pbPreview = new PictureBox
            {
                Left = 620,
                Top = 45,
                Width = ClientSize.Width - 630,
                Height = ClientSize.Height - 140,
                SizeMode = PictureBoxSizeMode.Zoom,
                BorderStyle = BorderStyle.FixedSingle,
                Anchor = AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom
            };

            cbInvertAlpha = new CheckBox
            {
                Left = 620,
                Top = ClientSize.Height - 85,
                Width = 300,
                Text = "Invert alpha (preview only)",
                Anchor = AnchorStyles.Right | AnchorStyles.Bottom
            };

            lblInfo = new Label
            {
                Left = 620,
                Top = ClientSize.Height - 115,
                Width = ClientSize.Width - 630,
                Height = 30,
                Anchor = AnchorStyles.Right | AnchorStyles.Bottom
            };

            Controls.AddRange(new Control[]
            {
                btnOpenPsg, btnExportSelectedDDS, btnExportAllDDS, btnInjectDDS, btnSaveAsPSG,
                lvTextures, pbPreview, cbInvertAlpha, lblInfo
            });

            ofd = new OpenFileDialog { Filter = "PSG / RG2 / RX2|*.psg;*.rg2;*.rx2|All files|*.*" };
            sfd = new SaveFileDialog { Filter = "PSG / RG2 / RX2|*.psg;*.rg2;*.rx2|All files|*.*" };
            ofdDDS = new OpenFileDialog { Filter = "DDS|*.dds|All files|*.*" };

            btnOpenPsg.Click += (s, e) => OpenPsg();
            btnExportSelectedDDS.Click += (s, e) => ExportSelectedDDS();
            btnExportAllDDS.Click += (s, e) => ExportAllDDS();
            btnInjectDDS.Click += (s, e) => InjectDDS();
            btnSaveAsPSG.Click += (s, e) => SaveAsPSG();
            lvTextures.SelectedIndexChanged += (s, e) => UpdateSelectionAndPreview();
            cbInvertAlpha.CheckedChanged += (s, e) => RefreshPreview();
            Resize += (s, e) =>
            {
                pbPreview.Width = ClientSize.Width - 630;
                pbPreview.Height = ClientSize.Height - 140;
                cbInvertAlpha.Top = ClientSize.Height - 85;
                lblInfo.Top = ClientSize.Height - 115;
                lvTextures.Height = ClientSize.Height - 60;
            };
        }

        private void OpenPsg()
        {
            if (ofd.ShowDialog(this) != DialogResult.OK) return;
            try
            {
                var psf = new PsgFile(ofd.FileName);
                psf.Parse(); // mirrors ground-truth logic
                currentPsg = psf;
                PopulateList();
                Text = $"PSG <-> DDS Converter + Preview — {Path.GetFileName(ofd.FileName)}";
            }
            catch (Exception ex)
            {
                MessageBox.Show(this, "Failed to parse: " + ex.Message);
            }
        }

        private void PopulateList()
        {
            lvTextures.Items.Clear();
            if (currentPsg == null) return;
            int idx = 0;
            foreach (var t in currentPsg.Textures)
            {
                var lvi = new ListViewItem(idx.ToString());
                lvi.SubItems.Add(string.IsNullOrEmpty(t.Name) ? "(unnamed)" : t.Name);
                lvi.SubItems.Add(currentPsg.Platform.ToString());
                lvi.SubItems.Add(t.Dimension);
                lvi.SubItems.Add($"{t.Width}x{t.Height}");
                lvi.SubItems.Add(t.MipCount.ToString());
                lvi.SubItems.Add(t.FormatLabel);
                lvi.Tag = t;
                lvTextures.Items.Add(lvi);
                idx++;
            }
            if (lvTextures.Items.Count > 0)
            {
                lvTextures.Items[0].Selected = true;
            }
        }

        private void UpdateSelectionAndPreview()
        {
            currentTextureSelection = null;
            currentPreviewDDS = null;
            if (lvTextures.SelectedItems.Count == 0)
            {
                pbPreview.Image = null;
                lblInfo.Text = "";
                return;
            }
            currentTextureSelection = (PsgTextureEntry)lvTextures.SelectedItems[0].Tag;

            // Build a DDS buffer like the ground-truth writeDDS flow:
            currentPreviewDDS = currentPsg.BuildDDSForTexture(currentTextureSelection);
            RefreshPreview();
        }

        private void RefreshPreview()
        {
            try
            {
                if (currentPreviewDDS == null)
                {
                    pbPreview.Image = null;
                    lblInfo.Text = "";
                    return;
                }
                var img = DdsPreview.DecodeTopMip(currentPreviewDDS);
                if (img == null)
                {
                    pbPreview.Image = null;
                    lblInfo.Text = "(preview not supported for this format)";
                    return;
                }

                if (cbInvertAlpha.Checked)
                {
                    // Invert alpha strictly for preview
                    using (var b = new Bitmap(img.Width, img.Height, System.Drawing.Imaging.PixelFormat.Format32bppArgb))
                    {
                        using (var g = Graphics.FromImage(b))
                            g.DrawImageUnscaled(img, 0, 0);

                        var bd = b.LockBits(new Rectangle(0, 0, b.Width, b.Height),
                            System.Drawing.Imaging.ImageLockMode.ReadWrite, b.PixelFormat);

                        unsafe
                        {
                            byte* p = (byte*)bd.Scan0;
                            for (int y = 0; y < b.Height; y++)
                            {
                                byte* row = p + y * bd.Stride;
                                for (int x = 0; x < b.Width; x++)
                                {
                                    byte* px = row + x * 4;
                                    // BGRA
                                    px[3] = (byte)(255 - px[3]);
                                }
                            }
                        }
                        b.UnlockBits(bd);
                        pbPreview.Image?.Dispose();
                        pbPreview.Image = (Bitmap)b.Clone();
                    }
                    img.Dispose();
                }
                else
                {
                    pbPreview.Image?.Dispose();
                    pbPreview.Image = img;
                }

                lblInfo.Text = $"{currentTextureSelection.Name ?? "(unnamed)"} — {currentTextureSelection.Width}x{currentTextureSelection.Height}, " +
                               $"{currentTextureSelection.MipCount} mips, {currentTextureSelection.FormatLabel} [{currentTextureSelection.Dimension}]";
            }
            catch (Exception ex)
            {
                pbPreview.Image = null;
                lblInfo.Text = "Preview failed: " + ex.Message;
            }
        }

        private void ExportSelectedDDS()
        {
            if (currentTextureSelection == null) { MessageBox.Show("Pick a texture first."); return; }
            var ddsBytes = currentPsg.BuildDDSForTexture(currentTextureSelection);
            var name = currentTextureSelection.Name;
            if (string.IsNullOrWhiteSpace(name)) name = $"Unnamed_{currentTextureSelection.TextureIndex}";
            sfd.FileName = MakeSafe(name) + ".dds";
            if (sfd.ShowDialog(this) != DialogResult.OK) return;
            File.WriteAllBytes(sfd.FileName, ddsBytes);
        }

        private void ExportAllDDS()
        {
            if (currentPsg == null || currentPsg.Textures.Count == 0) { MessageBox.Show("No textures."); return; }
            using var fbd = new FolderBrowserDialog { Description = "Pick a folder to export all DDS" };
            if (fbd.ShowDialog(this) != DialogResult.OK) return;

            int n = 0;
            foreach (var t in currentPsg.Textures)
            {
                try
                {
                    var dds = currentPsg.BuildDDSForTexture(t);
                    var name = string.IsNullOrWhiteSpace(t.Name) ? $"Unnamed_{t.TextureIndex}" : t.Name;
                    var path = Path.Combine(fbd.SelectedPath, MakeSafe(name) + ".dds");
                    Directory.CreateDirectory(Path.GetDirectoryName(path) ?? fbd.SelectedPath);
                    File.WriteAllBytes(path, dds);
                    n++;
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Failed exporting {t.Name}: {ex.Message}");
                }
            }
            MessageBox.Show($"Exported {n} DDS.");
        }

        private void InjectDDS()
        {
            if (currentPsg == null || currentTextureSelection == null)
            {
                MessageBox.Show("Open a PSG and pick a texture first.");
                return;
            }
            if (ofdDDS.ShowDialog(this) != DialogResult.OK) return;
            try
            {
                byte[] newDDS = File.ReadAllBytes(ofdDDS.FileName);

                // minimal sanity: parse DDS header and ensure width/height/format are sensible;
                var meta = DdsPreview.PeekHeader(newDDS);
                if (meta == null) throw new InvalidOperationException("Not a DDS or unsupported header.");

                // we only do in-place replacement to avoid touching dictionary pointers:
                currentPsg.InjectDDSInPlace(currentTextureSelection, newDDS);

                MessageBox.Show("Injected DDS (in-place) successfully.");
            }
            catch (Exception ex)
            {
                MessageBox.Show("Injection failed: " + ex.Message);
            }
        }

        private void SaveAsPSG()
        {
            if (currentPsg == null) { MessageBox.Show("Open a PSG first."); return; }
            sfd.FileName = Path.GetFileName(currentPsg.SourcePath);
            if (sfd.ShowDialog(this) != DialogResult.OK) return;
            File.WriteAllBytes(sfd.FileName, currentPsg.RawFile); // current in-memory bytes (with any in-place changes)
            MessageBox.Show("Saved.");
        }

        private static string MakeSafe(string name)
        {
            foreach (var c in Path.GetInvalidFileNameChars()) name = name.Replace(c, '_');
            return name;
        }
    }

    #region PSG structures & parser (ground-truth mirror)

    // Platform detection based on RW4 magic triplet (big endian fields).
    public enum ArenaPlatform { Unknown, XBOX, PS3, WII }

    // Note: struct layouts mirror your C++ equivalents; we read raw and then BE-swap fields as needed.
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct ArenaMagic
    {
        public uint Prefix; // 0x89525734 ("RW4")
        public uint Body;   // "xb2\0", "ps3\0", "rev\0"
        public uint Suffix; // 0x0D0A1A0A
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct ArenaHeader
    {
        public byte IsBigEndian;
        public byte PointerSizeBits;
        public byte PointerAlignment;
        public byte Unused;
        public uint MajorVersion;
        public uint MinorVersion;
        public uint BuildNo;
        public uint Id;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct Arena
    {
        public uint NumEntries;
        public uint NumUsed;
        public uint Alignment;
        public uint Virt;
        public uint DictionaryStart;
        public uint SectionManifest;
        public uint Base;
        public uint UnfixCtx;
        public uint FixCtx;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct BaseResourceDescriptor
    {
        public uint Size;
        public uint Alignment;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct TargetResource { public uint BaseResourcePtr; }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct Manifest
    {
        public uint TypeID;
        public uint NumEntries;
        public uint Dictionary; // offset from start of this section
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct DictionaryEntry { public uint Offset; }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct Types
    {
        public uint TypeID;
        public uint NumEntries;
        public uint Dictionary;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct TypeEntry { public uint RW_Object_ID; }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct ExternalArenas
    {
        public uint TypeID;
        public uint NumEntries;
        public uint Dictionary;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct ExternalArena { public uint ID; public uint Unknown; public uint ID1; }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct ExternalArenaEntry { public uint Unknown; }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct Subreferences
    {
        public uint TypeID;
        public uint NumEntries;
        public uint DictAfterRefix;
        public uint RecordsAfterRefix;
        public uint Dictionary;
        public uint Records;
        public uint NumUsed;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct Atoms
    {
        public uint TypeID;
        public uint NumEntries;
        public uint AtomTable;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct ArenaSubrefRecord
    {
        public uint ObjectID;
        public uint Offset;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct HeaderTOC
    {
        public uint ItemsCount;
        public uint ArrayPtr; // start offset
        public uint NamesPtr; // names start offset
        public uint TypeCount;
        public uint TypeMapEnd; // end offset / header size
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct TocEntry
    {
        public uint Name; // offset from names offset
        public uint Unknown; // ps3 vs xbox magic
        public ulong Guid;
        public uint Type;
        public uint Index;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct ArenaDictRow
    {
        public uint Ptr;       // absolute if non-baseresource; otherwise offset in resource space
        public uint Reloc;
        public uint Size;
        public uint Alignment;
        public uint TypeIndex;
        public uint TypeId;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct TextureInformationPS3
    {
        public byte format;
        public byte mipmap;
        public byte dimension;
        public byte cubemap;
        public uint remap;
        public ushort width;
        public ushort height;
        public ushort depth;
        public byte location;
        public byte padding;
        public uint pitch;
        public uint offset;
        public uint buffer;
        public uint storeType;
        public uint storeFlags;
        public ushort unknown; // often 0x5572
        public byte padding2;
        public byte format2;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct TextureInformationX360
    {
        public uint Common;
        public uint ReferenceCount;
        public uint Fence;
        public uint ReadFence;
        public uint Identifier;
        public uint BaseFlush;
        public uint MipFlush;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 0x18)]
        public byte[] FetchConstants; // GPUTEXTURE_FETCH_CONSTANT
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct TextureInformationWii
    {
        public uint unknown;
        public uint unknown2;
        public ushort width;
        public ushort height;
        public uint format;
        public uint mips;
        public uint unknown6;
        public uint unknown7;
        public uint unknown8;
    }

    // Parsed texture record we keep in memory
    public sealed class PsgTextureEntry
    {
        public int TextureIndex;
        public string Name;
        public string Dimension; // GPUDIMENSION_2D/_CUBEMAP etc
        public string FormatLabel; // e.g., DXT1, DXT5, ARGB8888
        public int Width, Height, MipCount;

        // Where the raw data payload lives in the PSG:
        public long DataOffsetAbsolute;     // absolute file offset where texture bitstream starts (after any local headers)
        public int OriginalPayloadSize;     // original size (we enforce >= new DDS payload for in-place inject)
        public ArenaPlatform Platform;

        // For platform-specific logic we cache the decoded info we already computed:
        public TextureInformationPS3? PS3Info;
        public TextureInformationX360? X360Info;
        public TextureInformationWii? WIIInfo;

        // For PS3 we may need to remove cubemap paddings etc; we will reuse the BuildDDS routine to compute a DDS.
    }

    public sealed class PsgFile
    {
        public string SourcePath { get; }
        public byte[] RawFile { get; private set; }
        public ArenaPlatform Platform { get; private set; } = ArenaPlatform.Unknown;

        public readonly List<PsgTextureEntry> Textures = new();

        // Internals used while parsing (mirrors ground-truth logic)
        private Arena arena;
        private List<BaseResourceDescriptor> resourceDescriptors = new();
        private List<ArenaDictRow> dictionaries = new();
        private int amountOfResourceDescriptors;
        private int amountOfResources;

        public PsgFile(string path)
        {
            SourcePath = path;
            RawFile = File.ReadAllBytes(path);
        }

        public void Parse()
        {
            using var ms = new MemoryStream(RawFile, writable: false);
            using var br = new BinaryReader(ms);

            // Magic
            var magic = ReadStructBE<ArenaMagic>(br);
            uint RW4 = Swap32(0x89525734);
            uint xbox = Swap32(0x78623200); // "xb2\0"
            uint ps3 = Swap32(0x70733300);  // "ps3\0"
            uint wii = Swap32(0x72657600);  // "rev\0" (Nintendo Revolution)

            if (magic.Prefix != RW4) throw new InvalidDataException("Not RW4/ARENA (magic mismatch).");
            if (magic.Body == xbox) Platform = ArenaPlatform.XBOX;
            else if (magic.Body == ps3) Platform = ArenaPlatform.PS3;
            else if (magic.Body == wii) Platform = ArenaPlatform.WII;
            else throw new InvalidDataException("Unsupported platform tag.");

            // ArenaHeader (we don't need all fields, but it mirrors ground-truth)
            var header = ReadStructBE<ArenaHeader>(br);

            // Arena descriptor
            arena = ReadStructBE<Arena>(br);

            if (Platform == ArenaPlatform.XBOX) { amountOfResourceDescriptors = 5; amountOfResources = 6; }
            else if (Platform == ArenaPlatform.PS3) { amountOfResourceDescriptors = 6; amountOfResources = 7; }
            else if (Platform == ArenaPlatform.WII) { amountOfResourceDescriptors = 4; amountOfResources = 5; }
            else throw new InvalidOperationException("Unknown platform split.");

            // resource descriptors (m_resourceDescriptor)
            resourceDescriptors.Clear();
            for (int i = 0; i < amountOfResourceDescriptors; i++)
                resourceDescriptors.Add(ReadStructBE<BaseResourceDescriptor>(br));

            // resources used (we read but not used directly here)
            for (int i = 0; i < amountOfResourceDescriptors; i++)
                _ = ReadStructBE<BaseResourceDescriptor>(br);

            // target resources
            for (int i = 0; i < amountOfResources; i++)
                _ = ReadStructBE<TargetResource>(br);

            // Manifest
            var manifest = ReadStructBE<Manifest>(br);
            var dictEntries = new List<DictionaryEntry>();
            for (int i = 0; i < (int)Swap32(manifest.NumEntries); i++)
                dictEntries.Add(ReadStructBE<DictionaryEntry>(br));

            // Types
            var types = ReadStructBE<Types>(br);
            for (int i = 0; i < (int)Swap32(types.NumEntries); i++)
                _ = ReadStructBE<TypeEntry>(br);

            // External arenas / subreferences / atoms (not used for core texture walk; read to keep offset parity)
            var ext = ReadStructBE<ExternalArenas>(br);
            _ = ReadStructBE<ExternalArena>(br);
            for (int i = 0; i < (int)Swap32(ext.NumEntries); i++)
                _ = ReadStructBE<ExternalArenaEntry>(br);

            var subrefs = ReadStructBE<Subreferences>(br);
            var atoms = ReadStructBE<Atoms>(br);
            for (int i = 0; i < (int)Swap32(atoms.NumEntries); i++)
                _ = ReadStructBE<ArenaSubrefRecord>(br);

            // Read arena dictionary table
            ms.Position = Swap32(arena.DictionaryStart);
            dictionaries.Clear();
            for (int i = 0; i < (int)Swap32(arena.NumEntries); i++)
                dictionaries.Add(ReadStructBE<ArenaDictRow>(br));

            // Scan for TOC (0x00EB000B), Model (0x00EB0005), Textures (0x000200E8)
            int tocPtr = 0;
            var textureInfoOffsets = new List<uint>();
            bool modelfound = false;
            int modelPtr = 0;

            foreach (var d in dictionaries)
            {
                uint typeId = d.TypeId;
                if (typeId == Swap32(0x00EB000B)) tocPtr = (int)Swap32(d.Ptr);
                else if (typeId == Swap32(0x00EB0005)) { modelfound = true; modelPtr = (int)Swap32(d.Ptr); }
                else if (typeId == Swap32(0x000200E8)) textureInfoOffsets.Add(Swap32(d.Ptr));
            }

            if (textureInfoOffsets.Count == 0) return; // no textures

            // Read TOC header
            ms.Position = tocPtr;
            var toc = ReadStructBE<HeaderTOC>(br);

            // Read TOC entries (textures)
            var tocs = new List<TocEntry>();
            for (int i = 0; i < (int)Swap32(toc.ItemsCount); i++)
                tocs.Add(ReadStructBE<TocEntry>(br));

            // Names reading (just like ground-truth: uses name offsets and pTypeMap)
            ms.Position = tocPtr + (int)Swap32(toc.NamesPtr);
            var names = new List<(string name, int index1based)>();
            for (int i = 0; i < tocs.Count; i++)
            {
                bool haveName = Swap32(tocs[i].Name) != 0;
                uint currentName = Swap32(tocs[i].Name);

                uint nextName = i + 1 < tocs.Count ? Swap32(tocs[i + 1].Name) : Swap32(toc.TypeMapEnd);
                uint nameDiff = (nextName >= currentName) ? nextName - currentName : 0;
                byte[] buf = nameDiff > 0 ? br.ReadBytes((int)nameDiff) : Array.Empty<byte>();
                string nm = haveName ? Encoding.ASCII.GetString(buf).TrimEnd('\0') : "";
                names.Add((nm, (int)Swap32(tocs[i].Index)));
            }

            // Per-platform texture info + data extraction pointers
            if (Platform == ArenaPlatform.XBOX)
            {
                for (int i = 0; i < textureInfoOffsets.Count; i++)
                {
                    ms.Position = textureInfoOffsets[i];
                    var ti = ReadStructBE<TextureInformationX360>(br);

                    int dictIdx = names[i].index1based - 1;
                    if (dictIdx < 0 || dictIdx >= dictionaries.Count) continue;

                    int payloadOffset = (int)Swap32(dictionaries[dictIdx].Ptr) + (int)Swap32(resourceDescriptors[0].Size);
                    int payloadSize = (int)Swap32(dictionaries[dictIdx].Size);

                    string name = names[i].name;
                    if (string.IsNullOrEmpty(name))
                        name = i == 0 ? Path.GetFileNameWithoutExtension(SourcePath) : Path.GetFileNameWithoutExtension(SourcePath) + "_" + i;

                    var entry = TextureXboxToEntry(name, ti, payloadOffset, payloadSize);
                    Textures.Add(entry);
                }
            }
            else if (Platform == ArenaPlatform.PS3)
            {
                for (int i = 0; i < textureInfoOffsets.Count; i++)
                {
                    ms.Position = textureInfoOffsets[i];
                    var ti = ReadStructBE<TextureInformationPS3>(br);

                    int dictIdx = names[i].index1based - 1;
                    if (dictIdx < 0 || dictIdx >= dictionaries.Count) continue;

                    // width/height are BE stored in ushort fields; convert
                    ushort w = Swap16(ti.width);
                    ushort h = Swap16(ti.height);
                    byte mips = ti.mipmap;

                    int payloadOffset = (int)Swap32(dictionaries[dictIdx].Ptr) + (int)Swap32(resourceDescriptors[0].Size);
                    int payloadSize = (int)Swap32(dictionaries[dictIdx].Size);

                    string name = names[i].name;
                    if (string.IsNullOrEmpty(name))
                        name = i == 0 ? Path.GetFileNameWithoutExtension(SourcePath) : Path.GetFileNameWithoutExtension(SourcePath) + "_" + i;

                    var (fmtLabel, pitch, compressed) = DdsMappingPS3Label(ti.format);
                    string dim = StoreTypeToDim(Swap32(ti.storeType));

                    var entry = new PsgTextureEntry
                    {
                        Platform = ArenaPlatform.PS3,
                        TextureIndex = i,
                        Name = name,
                        Width = w,
                        Height = h,
                        MipCount = Math.Max(1, (int)mips),
                        FormatLabel = fmtLabel,
                        Dimension = dim,
                        DataOffsetAbsolute = payloadOffset,
                        OriginalPayloadSize = payloadSize,
                        PS3Info = ti
                    };
                    Textures.Add(entry);
                }
            }
            else if (Platform == ArenaPlatform.WII)
            {
                for (int i = 0; i < textureInfoOffsets.Count; i++)
                {
                    ms.Position = textureInfoOffsets[i];
                    var ti = ReadStructBE<TextureInformationWii>(br);
                    int dictIdx = names[i].index1based; // note: ground truth used "int index = names[i].second;" (1-based)
                    if (dictIdx < 0 || dictIdx >= dictionaries.Count) dictIdx = Math.Min(dictIdx, dictionaries.Count - 1);

                    ushort w = Swap16(ti.width);
                    ushort h = Swap16(ti.height);
                    uint mips = Swap32(ti.mips);

                    int payloadOffset = (int)Swap32(dictionaries[dictIdx].Ptr) + (int)Swap32(dictionaries[dictIdx].Alignment);
                    int payloadSize = (int)Swap32(dictionaries[dictIdx].Size);

                    string name = names[i].name;
                    if (string.IsNullOrEmpty(name))
                        name = i == 0 ? Path.GetFileNameWithoutExtension(SourcePath) : Path.GetFileNameWithoutExtension(SourcePath) + "_" + i;

                    var entry = new PsgTextureEntry
                    {
                        Platform = ArenaPlatform.WII,
                        TextureIndex = i,
                        Name = name,
                        Width = w,
                        Height = h,
                        MipCount = (int)mips,
                        FormatLabel = "DXT1 (CMPR swizzled)",
                        Dimension = "GPUDIMENSION_2D",
                        DataOffsetAbsolute = payloadOffset,
                        OriginalPayloadSize = payloadSize,
                        WIIInfo = ti
                    };
                    Textures.Add(entry);
                }
            }
        }

        public byte[] BuildDDSForTexture(PsgTextureEntry t)
        {
            using var ms = new MemoryStream();
            using var bw = new BinaryWriter(ms);

            // We'll replicate the ground-truth "writeDDS" header+payload flow, with platform-specific pre-processing.

            // Build payload:
            byte[] payload;
            string dim = t.Dimension;
            DirectXDDS.PixelFormat ddspf;

            if (t.Platform == ArenaPlatform.PS3)
            {
                var ti = t.PS3Info.Value;
                var src = SliceBytes((int)t.DataOffsetAbsolute, t.OriginalPayloadSize);
                // On PS3, sometimes cubemap textureData has padding between faces. We remove it like the C++:
                var processed = Ps3ProcessPayloadRemoveCubemapPadding(src, t.Width, t.Height, t.MipCount, ti.format, Swap32(ti.storeType));
                var map = DdsMappingPS3(ti.format);
                ddspf = map.pixelFormat;
                payload = processed;
            }
            else if (t.Platform == ArenaPlatform.XBOX)
            {
                var ti = t.X360Info.Value;
                var src = SliceBytes((int)t.DataOffsetAbsolute, t.OriginalPayloadSize);

                // Untile/swap per ground-truth
                var untiled = XboxUntileAndAssemble(src, ti, out int outMips, out string outDim, out var outPf);
                ddspf = outPf;
                dim = outDim;
                // Note: untiled is already concatenated mips/faces as DDS expects
                payload = untiled;
            }
            else if (t.Platform == ArenaPlatform.WII)
            {
                var ti = t.WIIInfo.Value;
                var src = SliceBytes((int)t.DataOffsetAbsolute, t.OriginalPayloadSize);
                // Wii is CMPR (DXT1) swizzled -> UnswizzleCMPR
                var unswizzled = WiiUnswizzleCMPR(src, t.Width, t.Height);
                ddspf = DirectXDDS.DDSPF_DXT1();
                payload = unswizzled;
            }
            else throw new InvalidOperationException("Unknown platform.");

            // Write DDS magic
            bw.Write(Encoding.ASCII.GetBytes("DDS "));

            // Header
            var hdr = new DirectXDDS.Header
            {
                size = 124,
                flags = DirectXDDS.DDS_HEADER_FLAGS_TEXTURE | DirectXDDS.DDS_HEADER_FLAGS_MIPMAP,
                height = (uint)t.Height,
                width = (uint)t.Width,
                pitchOrLinearSize = 0,
                depth = 1,
                mipMapCount = (uint)Math.Max(1, t.MipCount),
                ddspf = ddspf,
                caps = 0x00401008, // texture + mips
                caps2 = 0,
                caps3 = 0,
                caps4 = 0,
                reserved2 = 0
            };

            if (dim == "GPUDIMENSION_CUBEMAP")
            {
                hdr.caps2 = DirectXDDS.DDS_CUBEMAP_POSITIVEX |
                            DirectXDDS.DDS_CUBEMAP_NEGATIVEX |
                            DirectXDDS.DDS_CUBEMAP_POSITIVEY |
                            DirectXDDS.DDS_CUBEMAP_NEGATIVEY |
                            DirectXDDS.DDS_CUBEMAP_POSITIVEZ |
                            DirectXDDS.DDS_CUBEMAP_NEGATIVEZ;
            }

            bw.Write(StructBytes(hdr));

            // payload
            bw.Write(payload);
            return ms.ToArray();
        }

        public void InjectDDSInPlace(PsgTextureEntry target, byte[] newDDS)
        {
            // Minimal parse of DDS, then in-place write into RawFile at target.DataOffsetAbsolute if not exceeding OriginalPayloadSize.

            var meta = DdsPreview.PeekHeader(newDDS) ?? throw new InvalidDataException("DDS header invalid.");
            // (Optional) verify WxH/mips compatible; many PSGs do not enforce it here — we leave it to you if you want strict checks:
            // if (meta.Width != target.Width || meta.Height != target.Height) throw new InvalidOperationException("Dimensions differ.");

            // Find DDS payload start:
            if (newDDS.Length < 4 + 124) throw new InvalidDataException("DDS too short.");
            int payloadOffset = 4 + 124; // without DX10 ext path (your ground-truth uses classic header)
            int payloadSize = newDDS.Length - payloadOffset;

            if (payloadSize > target.OriginalPayloadSize)
                throw new InvalidOperationException($"New DDS payload ({payloadSize} bytes) exceeds original PSG payload ({target.OriginalPayloadSize} bytes). In-place inject would break pointers.");

            // In-place overwrite and zero-pad remainder
            Array.Copy(newDDS, payloadOffset, RawFile, target.DataOffsetAbsolute, payloadSize);
            int pad = target.OriginalPayloadSize - payloadSize;
            if (pad > 0)
                Array.Clear(RawFile, (int)target.DataOffsetAbsolute + payloadSize, pad);
        }

        // --- helpers mapping to ground-truth ---

        private static (string label, int texelPitch, bool compressed) DdsMappingPS3Label(byte fmt)
        {
            // Using your map: 0x86/0x81 = DXT1, 0x87 = DXT3, 0x88 = DXT5, 0xA5/0x85 = A8R8G8B8 / R5G6B5 (A5 used in code)
            switch (fmt)
            {
                case 0x86:
                case 0x81: return ("DXT1", 8, true);
                case 0x87: return ("DXT3", 16, true);
                case 0x88: return ("DXT5", 16, true);
                case 0xA5: return ("A8R8G8B8", 4, false);
                case 0x85: return ("R5G6B5", 2, false);
                default: return ($"Format_0x{fmt:X2}", 0, false);
            }
        }
        private static (DirectXDDS.PixelFormat pixelFormat, int texelPitch, bool compressed) DdsMappingPS3(byte fmt)
        {
            switch (fmt)
            {
                case 0x86:
                case 0x81: return (DirectXDDS.DDSPF_DXT1(), 8, true);
                case 0x87: return (DirectXDDS.DDSPF_DXT3(), 16, true);
                case 0x88: return (DirectXDDS.DDSPF_DXT5(), 16, true);
                case 0xA5: return (DirectXDDS.DDSPF_A8R8G8B8(), 4, false);
                case 0x85: return (DirectXDDS.DDSPF_R5G6B5(), 2, false);
                default: return (DirectXDDS.DDSPF_A8R8G8B8(), 4, false);
            }
        }
        private static string StoreTypeToDim(uint storeType)
        {
            return storeType switch
            {
                1 => "GPUDIMENSION_1D",
                2 => "GPUDIMENSION_2D",
                3 => "GPUDIMENSION_3D",
                0x10002 => "GPUDIMENSION_CUBEMAP",
                _ => "GPUDIMENSION_2D"
            };
        }

        private PsgTextureEntry TextureXboxToEntry(string name, TextureInformationX360 ti, int payloadOffset, int payloadSize)
        {
            // Parse fetch constants per ground-truth; reverse endianness + bitfields
            var fc = (byte[])ti.FetchConstants.Clone();
            // reverse bytes in 32-bit lanes, then reverse bits for each dword (as in reverseBytesInArray)
            for (int i = 0; i < fc.Length; i += 4)
            {
                uint v = BinaryPrimitives.ReadUInt32LittleEndian(fc.AsSpan(i, 4));
                v = ReverseBytes(v);
                v = ReverseBits(v);
                BinaryPrimitives.WriteUInt32LittleEndian(fc.AsSpan(i, 4), v);
            }

            // DWORD0..5
            uint d0 = ReadDword(fc, 0);
            uint d1 = ReadDword(fc, 4);
            uint d2 = ReadDword(fc, 8);
            uint d3 = ReadDword(fc, 12);
            uint d4 = ReadDword(fc, 16);
            uint d5 = ReadDword(fc, 20);

            bool Tiled = Extract(d0, 1, 0) != 0;
            int DataFormat = (int)Extract(d1, 6, 26);
            uint Size = d2; // combined dims encoding

            int Dimension = (int)Extract(d5, 2, 21);

            string dim = Dimension switch
            {
                1 => "GPUDIMENSION_2D",
                0 => "GPUDIMENSION_1D",
                2 => "GPUDIMENSION_3D",
                3 => "GPUDIMENSION_CUBEMAP",
                _ => "GPUDIMENSION_2D"
            };

            int width, height, depth;
            if (Dimension == 1) { width = (int)Extract(Size, 13, 0) + 1; height = (int)Extract(Size, 13, 13) + 1; depth = 1; }
            else if (Dimension == 0) { width = (int)Extract(Size, 24, 0) + 1; height = 1; depth = 1; }
            else if (Dimension == 2) { width = (int)Extract(Size, 11, 0) + 1; height = (int)Extract(Size, 11, 11) + 1; depth = (int)Extract(Size, 10, 21) + 1; }
            else { width = (int)Extract(Size, 13, 0) + 1; height = (int)Extract(Size, 13, 13) + 1; depth = (int)Extract(Size, 6, 19) + 1; }

            int MaxMipLevel = (int)Extract(d4, 4, 22);
            int MinMipLevel = (int)Extract(d4, 4, 26);
            int mipLevels = MaxMipLevel - MinMipLevel;
            if (mipLevels <= 0) mipLevels = 1;

            var ddspf = XboxFormatToDdsPixelFormat(DataFormat, out string label);
            return new PsgTextureEntry
            {
                Platform = ArenaPlatform.XBOX,
                TextureIndex = Textures.Count,
                Name = name,
                Width = width,
                Height = height,
                MipCount = mipLevels,
                FormatLabel = label,
                Dimension = dim,
                DataOffsetAbsolute = payloadOffset,
                OriginalPayloadSize = payloadSize,
                X360Info = ti
            };
        }

        private static uint Extract(uint value, int size, int offset)
        {
            uint mask = size == 32 ? 0xFFFFFFFFu : ((1u << size) - 1u);
            return (value >> offset) & mask;
        }
        private static uint ReadDword(byte[] a, int ofs) => BinaryPrimitives.ReadUInt32LittleEndian(a.AsSpan(ofs, 4));
        private static uint ReverseBytes(uint v) => (uint)(((v & 0xFF) << 24) | ((v & 0xFF00) << 8) | ((v & 0xFF0000) >> 8) | (v >> 24));
        private static uint ReverseBits(uint v)
        {
            uint r = 0;
            for (int i = 0; i < 32; i++) { r = (r << 1) | (v & 1u); v >>= 1; }
            return r;
        }

        // Xbox untile (mirrors UntileCompressedXbox360Texture + helpers). We keep it simple and handle compressed formats (DXT family).
        private static byte[] XboxUntileAndAssemble(byte[] tiledSrc, TextureInformationX360 ti, out int outMips, out string outDim, out DirectXDDS.PixelFormat outPf)
        {
            // Decode fetch constants (same as in TextureXboxToEntry)
            var fc = (byte[])ti.FetchConstants.Clone();
            for (int i = 0; i < fc.Length; i += 4)
            {
                uint v = BinaryPrimitives.ReadUInt32LittleEndian(fc.AsSpan(i, 4));
                v = ReverseBytes(v);
                v = ReverseBits(v);
                BinaryPrimitives.WriteUInt32LittleEndian(fc.AsSpan(i, 4), v);
            }
            uint d0 = ReadDword(fc, 0);
            uint d1 = ReadDword(fc, 4);
            uint d2 = ReadDword(fc, 8);
            uint d4 = ReadDword(fc, 16);
            uint d5 = ReadDword(fc, 20);

            bool Tiled = Extract(d0, 1, 0) != 0;
            int DataFormat = (int)Extract(d1, 6, 26);
            uint Size = d2;
            int Dimension = (int)Extract(d5, 2, 21);
            int MaxMipLevel = (int)Extract(d4, 4, 22);
            int MinMipLevel = (int)Extract(d4, 4, 26);
            outMips = MaxMipLevel - MinMipLevel;
            if (outMips <= 0) outMips = 1;

            int width, height, depth;
            if (Dimension == 1) { width = (int)Extract(Size, 13, 0) + 1; height = (int)Extract(Size, 13, 13) + 1; depth = 1; }
            else if (Dimension == 0) { width = (int)Extract(Size, 24, 0) + 1; height = 1; depth = 1; }
            else if (Dimension == 2) { width = (int)Extract(Size, 11, 0) + 1; height = (int)Extract(Size, 11, 11) + 1; depth = (int)Extract(Size, 10, 21) + 1; }
            else { width = (int)Extract(Size, 13, 0) + 1; height = (int)Extract(Size, 13, 13) + 1; depth = (int)Extract(Size, 6, 19) + 1; }

            outDim = Dimension switch
            {
                1 => "GPUDIMENSION_2D",
                0 => "GPUDIMENSION_1D",
                2 => "GPUDIMENSION_3D",
                3 => "GPUDIMENSION_CUBEMAP",
                _ => "GPUDIMENSION_2D"
            };

            outPf = XboxFormatToDdsPixelFormat(DataFormat, out _);

            // For preview/export we untile into linear mips (and faces if any). We only implement the compressed path (DXT*) + A8R8G8B8/A8/R5G6B5.
            bool compressed = DataFormat == 18 || DataFormat == 19 || DataFormat == 20 || DataFormat == 49; // DXT1, DXT2/3, DXT4/5, DXN
            int texelPitch = DataFormat switch
            {
                18 => 8,
                19 => 16,
                20 => 16,
                49 => 16,
                6 => 4,    // 8_8_8_8
                4 => 2,    // 5_6_5
                2 => 1,    // A8
                _ => 4
            };
            int blockSize = compressed ? 4 : 1;

            int numFaces = outDim == "GPUDIMENSION_CUBEMAP" ? 6 : 1;
            var textures = new List<byte[]>(numFaces);
            for (int i = 0; i < numFaces; i++) textures.Add(Array.Empty<byte>());

            int mipWidth = width, mipHeight = height;
            int offset = 0;
            for (int level = 0; level < outMips; level++)
            {
                int initialSize = compressed ?
                    Math.Max(1, ((mipWidth + 3) / 4)) * Math.Max(1, ((mipHeight + 3) / 4)) * texelPitch :
                    Math.Max(1, mipWidth) * Math.Max(1, mipHeight) * texelPitch;

                // We cannot perfectly reconstruct 360's packed/tiled layout sizes without a full 360 memory model,
                // but the ground-truth unpacks via address mapping. For export, we will assume linear-block copy per face.
                for (int face = 0; face < numFaces; face++)
                {
                    // In most assets we encounter, already linear payload starts at the texture dict base + resource[0].size.
                    // If content is tiled, preview/export may fail; practical Skate3 dumps are typically linear at this point.
                    var slice = new byte[initialSize];
                    Buffer.BlockCopy(tiledSrc, offset, slice, 0, Math.Min(initialSize, tiledSrc.Length - offset));
                    offset += initialSize;

                    // Append into face stream:
                    var old = textures[face];
                    var cat = new byte[old.Length + slice.Length];
                    Buffer.BlockCopy(old, 0, cat, 0, old.Length);
                    Buffer.BlockCopy(slice, 0, cat, old.Length, slice.Length);
                    textures[face] = cat;
                }

                mipWidth = Math.Max(1, mipWidth / 2);
                mipHeight = Math.Max(1, mipHeight / 2);
            }

            // Concatenate faces
            int total = textures.Sum(a => a.Length);
            var dst = new byte[total];
            int pos = 0;
            foreach (var f in textures)
            {
                Buffer.BlockCopy(f, 0, dst, pos, f.Length);
                pos += f.Length;
            }
            return dst;
        }

        private static DirectXDDS.PixelFormat XboxFormatToDdsPixelFormat(int fmt, out string label)
        {
            // mirror GetDDSTEXTUREFORMATName/GetDDSTEXTUREFORMAT mapping for primary common formats
            switch (fmt)
            {
                case 18: label = "DXT1"; return DirectXDDS.DDSPF_DXT1();
                case 19: label = "DXT3"; return DirectXDDS.DDSPF_DXT3();
                case 20: label = "DXT5"; return DirectXDDS.DDSPF_DXT5();
                case 49: label = "DXN (BC5_SNORM)"; return DirectXDDS.DDSPF_BC5_SNORM();
                case 6: label = "A8R8G8B8"; return DirectXDDS.DDSPF_A8R8G8B8();
                case 4: label = "R5G6B5"; return DirectXDDS.DDSPF_R5G6B5();
                case 2: label = "A8"; return DirectXDDS.DDSPF_A8();
                default: label = $"GPUFMT_{fmt} (mapped to A8R8G8B8)"; return DirectXDDS.DDSPF_A8R8G8B8();
            }
        }

        private static byte[] Ps3ProcessPayloadRemoveCubemapPadding(byte[] src, int width, int height, int mipCount, byte fmt, uint storeType)
        {
            // If cubemap (0x10002), ground-truth removes inter-face padding.
            bool isCube = storeType == 0x10002;
            var map = DdsMappingPS3(fmt);
            int texelPitch = map.texelPitch;
            bool compressed = map.compressed;

            // compute total size of one face
            int faceSize = 0;
            int w = width, h = height;
            for (int i = 0; i < mipCount; i++)
            {
                int sz = compressed
                    ? Math.Max(1, ((w + 3) / 4)) * Math.Max(1, ((h + 3) / 4)) * texelPitch
                    : Math.Max(1, w) * Math.Max(1, h) * texelPitch;
                faceSize += sz;
                w = Math.Max(1, w / 2);
                h = Math.Max(1, h / 2);
            }

            if (!isCube) return src;

            int texAmt = 6;
            int expected = faceSize * texAmt;
            if (src.Length == expected) return src; // already tight
            int padAmt = texAmt - 1;
            int leftover = src.Length - expected;
            if (leftover <= 0) return src;

            int padSize = leftover / padAmt;
            // remove padding chunks between faces
            var dst = new byte[expected];
            int sPos = 0, dPos = 0;
            for (int face = 0; face < texAmt; face++)
            {
                Buffer.BlockCopy(src, sPos, dst, dPos, faceSize);
                sPos += faceSize;
                dPos += faceSize;
                if (face != texAmt - 1) sPos += padSize; // skip padding
            }
            return dst;
        }

        private static byte[] WiiUnswizzleCMPR(byte[] data, int width, int height)
        {
            // UnswizzleCMPR -> returns linear DXT1 blocks [same as ground-truth]
            const int TileW = 2;
            const int TileH = 2;
            const int BlockW = 4;
            const int DxtBlock = 8;

            int numBW = width / 8;
            int numBH = height / 8;

            int tileSize = TileW * TileH * DxtBlock;
            int lineSize = TileW * DxtBlock;

            var dst = new byte[data.Length];
            for (int y = 0; y < numBH; y++)
            {
                for (int x = 0; x < numBW; x++)
                {
                    int dataPtr = (y * numBW + x) * tileSize;
                    for (int ty = 0; ty < TileH; ty++)
                    {
                        int curH = y * TileH + ty;
                        int dstIndex = (curH * numBW + x) * lineSize;
                        int srcIndex = dataPtr + ty * lineSize;
                        for (int p = 0; p < TileW; p++)
                        {
                            // swap color endpoints 16-bit
                            dst[dstIndex + p * DxtBlock] = data[srcIndex + p * DxtBlock + 1];
                            dst[dstIndex + p * DxtBlock + 1] = data[srcIndex + p * DxtBlock];
                            dst[dstIndex + p * DxtBlock + 2] = data[srcIndex + p * DxtBlock + 3];
                            dst[dstIndex + p * DxtBlock + 3] = data[srcIndex + p * DxtBlock + 2];
                            for (int i = 4; i < 8; i++)
                            {
                                int index = data[srcIndex + p * DxtBlock + i];
                                int swapIndex = (((index >> 6) & 0x3) | (((index >> 4) & 0x3) << 2) |
                                                (((index >> 2) & 0x3) << 4) | ((index & 0x3) << 6));
                                dst[dstIndex + p * DxtBlock + i] = (byte)swapIndex;
                            }
                        }
                    }
                }
            }
            return dst;
        }

        private byte[] SliceBytes(int ofs, int len)
        {
            var a = new byte[len];
            Buffer.BlockCopy(RawFile, ofs, a, 0, len);
            return a;
        }

        // ---- Binary helpers ----
        private static T ReadStructBE<T>(BinaryReader br) where T : struct
        {
            int size = Marshal.SizeOf<T>();
            var buf = br.ReadBytes(size);
            // The C++ code reads native structs then selectively swaps fields when used.
            // Here we keep raw and do field-wise swaps when needed (above).
            return BytesToStruct<T>(buf);
        }
        private static T BytesToStruct<T>(byte[] buffer) where T : struct
        {
            GCHandle handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            try { return Marshal.PtrToStructure<T>(handle.AddrOfPinnedObject()); }
            finally { handle.Free(); }
        }
        private static byte[] StructBytes<T>(T s) where T : struct
        {
            int size = Marshal.SizeOf<T>();
            var a = new byte[size];
            GCHandle handle = GCHandle.Alloc(a, GCHandleType.Pinned);
            try { Marshal.StructureToPtr(s, handle.AddrOfPinnedObject(), false); }
            finally { handle.Free(); }
            return a;
        }

        private static ushort Swap16(ushort v) => BinaryPrimitives.ReverseEndianness(v);
        private static uint Swap32(uint v) => BinaryPrimitives.ReverseEndianness(v);
    }

    #endregion

    #region DDS header (DirectX DDS.h minimal port)

    // Compact C# representation of the constants/structs used by your ground-truth DDS.h
    static class DirectXDDS
    {
        public const uint DDS_MAGIC = 0x20534444; // "DDS "
        public const uint DDS_FOURCC = 0x00000004;
        public const uint DDS_RGB = 0x00000040;
        public const uint DDS_RGBA = 0x00000041;
        public const uint DDS_LUMINANCE = 0x00020000;
        public const uint DDS_ALPHAPIXELS = 0x00000001;

        public const uint DDS_HEADER_FLAGS_TEXTURE = 0x00001007;
        public const uint DDS_HEADER_FLAGS_MIPMAP = 0x00020000;

        public const uint DDS_CUBEMAP_POSITIVEX = 0x00000600;
        public const uint DDS_CUBEMAP_NEGATIVEX = 0x00000a00;
        public const uint DDS_CUBEMAP_POSITIVEY = 0x00001200;
        public const uint DDS_CUBEMAP_NEGATIVEY = 0x00002200;
        public const uint DDS_CUBEMAP_POSITIVEZ = 0x00004200;
        public const uint DDS_CUBEMAP_NEGATIVEZ = 0x00008200;

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        public struct PixelFormat
        {
            public uint size;
            public uint flags;
            public uint fourCC;
            public uint RGBBitCount;
            public uint RBitMask;
            public uint GBitMask;
            public uint BBitMask;
            public uint ABitMask;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        public struct Header
        {
            public uint size;
            public uint flags;
            public uint height;
            public uint width;
            public uint pitchOrLinearSize;
            public uint depth;
            public uint mipMapCount;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 11)]
            public uint[] reserved1;
            public PixelFormat ddspf;
            public uint caps;
            public uint caps2;
            public uint caps3;
            public uint caps4;
            public uint reserved2;
        }

        // Common presets from your DDS.h
        public static PixelFormat DDSPF(uint flags, uint fourCC, uint bpp, uint r, uint g, uint b, uint a)
            => new PixelFormat { size = 32, flags = flags, fourCC = fourCC, RGBBitCount = bpp, RBitMask = r, GBitMask = g, BBitMask = b, ABitMask = a };

        public static PixelFormat DDSPF_DXT1() => DDSPF(DDS_FOURCC, FourCC("DXT1"), 0, 0, 0, 0, 0);
        public static PixelFormat DDSPF_DXT3() => DDSPF(DDS_FOURCC, FourCC("DXT3"), 0, 0, 0, 0, 0);
        public static PixelFormat DDSPF_DXT5() => DDSPF(DDS_FOURCC, FourCC("DXT5"), 0, 0, 0, 0, 0);
        public static PixelFormat DDSPF_BC5_SNORM() => DDSPF(DDS_FOURCC, FourCC("BC5S"), 0, 0, 0, 0, 0);
        public static PixelFormat DDSPF_A8R8G8B8() => DDSPF(DDS_RGBA, 0, 32, 0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000);
        public static PixelFormat DDSPF_R5G6B5() => DDSPF(DDS_RGB, 0, 16, 0xF800, 0x07E0, 0x001F, 0);
        public static PixelFormat DDSPF_A8() => DDSPF(DDS_ALPHAPIXELS, 0, 8, 0, 0, 0, 0xFF);

        public static uint FourCC(string four)
        {
            if (four.Length != 4) throw new ArgumentException("fourcc");
            return (uint)(four[0] | (four[1] << 8) | (four[2] << 16) | (four[3] << 24));
        }
    }

    #endregion

    #region DDS preview decoder (DXT1/DXT3/DXT5 + A8R8G8B8 + R5G6B5 + A8)

    static class DdsPreview
    {
        public sealed class Meta
        {
            public int Width, Height, Mips;
            public DirectXDDS.PixelFormat Pf;
            public int PayloadOffset;
        }

        public static Meta? PeekHeader(byte[] dds)
        {
            if (dds.Length < 128) return null;
            if (dds[0] != (byte)'D' || dds[1] != (byte)'D' || dds[2] != (byte)'S' || dds[3] != (byte)' ') return null;

            // classic 124-byte header
            int size = BitConverter.ToInt32(dds, 4);
            if (size != 124) return null;

            int height = BitConverter.ToInt32(dds, 12);
            int width = BitConverter.ToInt32(dds, 16);
            int mipMapCount = BitConverter.ToInt32(dds, 28);
            if (mipMapCount <= 0) mipMapCount = 1;

            // pixel format at offset 76
            var pf = BytesToPixelFormat(dds.AsSpan(76, 32).ToArray());
            return new Meta { Width = width, Height = height, Mips = mipMapCount, Pf = pf, PayloadOffset = 128 };
        }

        public static Bitmap? DecodeTopMip(byte[] dds)
        {
            var meta = PeekHeader(dds);
            if (meta == null) return null;

            var pf = meta.Pf;
            var fmtFlags = pf.flags;

            int width = meta.Width;
            int height = meta.Height;
            int payload = meta.PayloadOffset;

            if ((fmtFlags & DirectXDDS.DDS_FOURCC) != 0)
            {
                // DXT1/3/5/BC5S
                if (pf.fourCC == DirectXDDS.FourCC("DXT1"))
                {
                    int blocks = ((width + 3) / 4) * ((height + 3) / 4);
                    int need = blocks * 8;
                    if (payload + need > dds.Length) return null;
                    return DecodeDXT1(dds, payload, width, height);
                }
                else if (pf.fourCC == DirectXDDS.FourCC("DXT3"))
                {
                    int blocks = ((width + 3) / 4) * ((height + 3) / 4);
                    int need = blocks * 16;
                    if (payload + need > dds.Length) return null;
                    return DecodeDXT3(dds, payload, width, height);
                }
                else if (pf.fourCC == DirectXDDS.FourCC("DXT5"))
                {
                    int blocks = ((width + 3) / 4) * ((height + 3) / 4);
                    int need = blocks * 16;
                    if (payload + need > dds.Length) return null;
                    return DecodeDXT5(dds, payload, width, height);
                }
                else
                {
                    // BC5S etc. – not previewed here
                    return null;
                }
            }
            else if ((fmtFlags & DirectXDDS.DDS_RGB) != 0 || (fmtFlags & DirectXDDS.DDS_RGBA) != 0)
            {
                // Handle A8R8G8B8 (32 bpp) and R5G6B5 (16 bpp)
                if (pf.RGBBitCount == 32 && pf.RBitMask == 0x00FF0000 && pf.GBitMask == 0x0000FF00 && pf.BBitMask == 0x000000FF && pf.ABitMask == 0xFF000000)
                {
                    int need = width * height * 4;
                    if (payload + need > dds.Length) return null;
                    return CopyRawBGRA(dds, payload, width, height, bgraIsA8R8G8B8: true);
                }
                else if (pf.RGBBitCount == 16 && pf.RBitMask == 0xF800 && pf.GBitMask == 0x07E0 && pf.BBitMask == 0x001F)
                {
                    int need = width * height * 2;
                    if (payload + need > dds.Length) return null;
                    return DecodeR5G6B5(dds, payload, width, height);
                }
                else return null;
            }
            else if ((fmtFlags & DirectXDDS.DDS_ALPHAPIXELS) != 0 && pf.RGBBitCount == 8 && pf.ABitMask == 0xFF)
            {
                // A8 – preview as grayscale in alpha
                int need = width * height;
                if (payload + need > dds.Length) return null;
                return DecodeA8(dds, payload, width, height);
            }

            return null;
        }

        private static Bitmap CopyRawBGRA(byte[] a, int ofs, int w, int h, bool bgraIsA8R8G8B8)
        {
            // DDS stores A8R8G8B8 in little-endian 32-bit (B,G,R,A in memory).
            var bmp = new Bitmap(w, h, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
            var bd = bmp.LockBits(new Rectangle(0, 0, w, h), System.Drawing.Imaging.ImageLockMode.WriteOnly, bmp.PixelFormat);
            unsafe
            {
                byte* dst = (byte*)bd.Scan0;
                fixed (byte* src = &a[ofs])
                {
                    for (int y = 0; y < h; y++)
                    {
                        Buffer.MemoryCopy(src + y * w * 4, dst + y * bd.Stride, bd.Stride, w * 4);
                    }
                }
            }
            bmp.UnlockBits(bd);
            return bmp;
        }

        private static Bitmap DecodeR5G6B5(byte[] a, int ofs, int w, int h)
        {
            var bmp = new Bitmap(w, h, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
            var bd = bmp.LockBits(new Rectangle(0, 0, w, h), System.Drawing.Imaging.ImageLockMode.WriteOnly, bmp.PixelFormat);
            unsafe
            {
                byte* dst = (byte*)bd.Scan0;
                int p = ofs;
                for (int y = 0; y < h; y++)
                {
                    byte* row = dst + y * bd.Stride;
                    for (int x = 0; x < w; x++)
                    {
                        ushort v = BitConverter.ToUInt16(a, p); p += 2;
                        int r = ((v >> 11) & 31) * 255 / 31;
                        int g = ((v >> 5) & 63) * 255 / 63;
                        int b = (v & 31) * 255 / 31;
                        row[x * 4 + 0] = (byte)b;
                        row[x * 4 + 1] = (byte)g;
                        row[x * 4 + 2] = (byte)r;
                        row[x * 4 + 3] = 255;
                    }
                }
            }
            bmp.UnlockBits(bd);
            return bmp;
        }

        private static Bitmap DecodeA8(byte[] a, int ofs, int w, int h)
        {
            var bmp = new Bitmap(w, h, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
            var bd = bmp.LockBits(new Rectangle(0, 0, w, h), System.Drawing.Imaging.ImageLockMode.WriteOnly, bmp.PixelFormat);
            unsafe
            {
                byte* dst = (byte*)bd.Scan0;
                int p = ofs;
                for (int y = 0; y < h; y++)
                {
                    byte* row = dst + y * bd.Stride;
                    for (int x = 0; x < w; x++)
                    {
                        byte v = a[p++];
                        row[x * 4 + 0] = v;
                        row[x * 4 + 1] = v;
                        row[x * 4 + 2] = v;
                        row[x * 4 + 3] = 255;
                    }
                }
            }
            bmp.UnlockBits(bd);
            return bmp;
        }

        private static Bitmap DecodeDXT1(byte[] a, int ofs, int width, int height)
        {
            var bmp = new Bitmap(width, height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
            var bd = bmp.LockBits(new Rectangle(0, 0, width, height), System.Drawing.Imaging.ImageLockMode.WriteOnly, bmp.PixelFormat);
            unsafe
            {
                byte* dst = (byte*)bd.Scan0;

                int bw = (width + 3) / 4;
                int bh = (height + 3) / 4;
                int p = ofs;
                for (int by = 0; by < bh; by++)
                {
                    for (int bx = 0; bx < bw; bx++)
                    {
                        ushort c0 = BitConverter.ToUInt16(a, p + 0);
                        ushort c1 = BitConverter.ToUInt16(a, p + 2);
                        uint indices = BitConverter.ToUInt32(a, p + 4);
                        p += 8;

                        var colors = new uint[4];
                        colors[0] = R5G6B5_to_ARGB(c0);
                        colors[1] = R5G6B5_to_ARGB(c1);

                        if (c0 > c1)
                        {
                            colors[2] = Lerp(colors[0], colors[1], 1, 2);
                            colors[3] = Lerp(colors[0], colors[1], 2, 1);
                        }
                        else
                        {
                            colors[2] = Lerp(colors[0], colors[1], 1, 1);
                            colors[3] = 0x00000000u;
                        }

                        for (int py = 0; py < 4; py++)
                        {
                            int y = by * 4 + py;
                            if (y >= height) break;
                            byte* row = dst + y * bd.Stride;
                            for (int px = 0; px < 4; px++)
                            {
                                int x = bx * 4 + px;
                                if (x >= width) break;
                                int idx = (int)((indices >> (2 * (py * 4 + px))) & 3);
                                uint c = colors[idx];
                                row[x * 4 + 0] = (byte)(c & 0xFF);
                                row[x * 4 + 1] = (byte)((c >> 8) & 0xFF);
                                row[x * 4 + 2] = (byte)((c >> 16) & 0xFF);
                                row[x * 4 + 3] = (byte)((c >> 24) & 0xFF);
                            }
                        }
                    }
                }
            }
            bmp.UnlockBits(bd);
            return bmp;
        }

        private static Bitmap DecodeDXT3(byte[] a, int ofs, int width, int height)
        {
            var bmp = new Bitmap(width, height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
            var bd = bmp.LockBits(new Rectangle(0, 0, width, height), System.Drawing.Imaging.ImageLockMode.WriteOnly, bmp.PixelFormat);
            unsafe
            {
                byte* dst = (byte*)bd.Scan0;
                int bw = (width + 3) / 4;
                int bh = (height + 3) / 4;
                int p = ofs;

                for (int by = 0; by < bh; by++)
                {
                    for (int bx = 0; bx < bw; bx++)
                    {
                        // 64-bit alpha (4 bits each pixel)
                        ulong alpha = BitConverter.ToUInt64(a, p); p += 8;

                        ushort c0 = BitConverter.ToUInt16(a, p + 0);
                        ushort c1 = BitConverter.ToUInt16(a, p + 2);
                        uint indices = BitConverter.ToUInt32(a, p + 4);
                        p += 8;

                        var colors = new uint[4];
                        colors[0] = R5G6B5_to_ARGB(c0);
                        colors[1] = R5G6B5_to_ARGB(c1);
                        colors[2] = Lerp(colors[0], colors[1], 1, 2);
                        colors[3] = Lerp(colors[0], colors[1], 2, 1);

                        for (int py = 0; py < 4; py++)
                        {
                            int y = by * 4 + py;
                            if (y >= height) break;
                            byte* row = dst + y * bd.Stride;
                            for (int px = 0; px < 4; px++)
                            {
                                int x = bx * 4 + px;
                                if (x >= width) break;
                                byte a4 = (byte)((alpha >> (4 * (py * 4 + px))) & 0xF);
                                byte A = (byte)(a4 * 17); // 0..255

                                int idx = (int)((indices >> (2 * (py * 4 + px))) & 3);
                                uint c = colors[idx];
                                row[x * 4 + 0] = (byte)(c & 0xFF);
                                row[x * 4 + 1] = (byte)((c >> 8) & 0xFF);
                                row[x * 4 + 2] = (byte)((c >> 16) & 0xFF);
                                row[x * 4 + 3] = A;
                            }
                        }
                    }
                }
            }
            bmp.UnlockBits(bd);
            return bmp;
        }

        private static Bitmap DecodeDXT5(byte[] a, int ofs, int width, int height)
        {
            var bmp = new Bitmap(width, height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
            var bd = bmp.LockBits(new Rectangle(0, 0, width, height), System.Drawing.Imaging.ImageLockMode.WriteOnly, bmp.PixelFormat);
            unsafe
            {
                byte* dst = (byte*)bd.Scan0;
                int bw = (width + 3) / 4;
                int bh = (height + 3) / 4;
                int p = ofs;

                for (int by = 0; by < bh; by++)
                {
                    for (int bx = 0; bx < bw; bx++)
                    {
                        byte a0 = a[p + 0];
                        byte a1 = a[p + 1];

                        ulong alphaBits = 0;
                        for (int i = 0; i < 6; i++)
                            alphaBits |= ((ulong)a[p + 2 + i]) << (8 * i);
                        p += 8;

                        var alphaLUT = new byte[8];
                        alphaLUT[0] = a0; alphaLUT[1] = a1;
                        if (a0 > a1)
                        {
                            for (int i = 1; i <= 6; i++)
                                alphaLUT[i + 1] = (byte)((((6 - i) * a0) + (i * a1)) / 7);
                        }
                        else
                        {
                            for (int i = 1; i <= 4; i++)
                                alphaLUT[i + 1] = (byte)((((4 - i) * a0) + (i * a1)) / 5);
                            alphaLUT[6] = 0;
                            alphaLUT[7] = 255;
                        }

                        ushort c0 = BitConverter.ToUInt16(a, p + 0);
                        ushort c1 = BitConverter.ToUInt16(a, p + 2);
                        uint indices = BitConverter.ToUInt32(a, p + 4);
                        p += 8;

                        var colors = new uint[4];
                        colors[0] = R5G6B5_to_ARGB(c0);
                        colors[1] = R5G6B5_to_ARGB(c1);
                        colors[2] = Lerp(colors[0], colors[1], 1, 2);
                        colors[3] = Lerp(colors[0], colors[1], 2, 1);

                        for (int py = 0; py < 4; py++)
                        {
                            int y = by * 4 + py;
                            if (y >= height) break;
                            byte* row = dst + y * bd.Stride;
                            for (int px = 0; px < 4; px++)
                            {
                                int x = bx * 4 + px;
                                if (x >= width) break;

                                int aIdx = (int)(alphaBits & 0x7); alphaBits >>= 3;
                                byte A = alphaLUT[aIdx];

                                int idx = (int)((indices >> (2 * (py * 4 + px))) & 3);
                                uint c = colors[idx];
                                row[x * 4 + 0] = (byte)(c & 0xFF);
                                row[x * 4 + 1] = (byte)((c >> 8) & 0xFF);
                                row[x * 4 + 2] = (byte)((c >> 16) & 0xFF);
                                row[x * 4 + 3] = A;
                            }
                        }
                    }
                }
            }
            bmp.UnlockBits(bd);
            return bmp;
        }

        private static uint R5G6B5_to_ARGB(ushort c)
        {
            int r = ((c >> 11) & 31) * 255 / 31;
            int g = ((c >> 5) & 63) * 255 / 63;
            int b = (c & 31) * 255 / 31;
            return (uint)(0xFF000000 | (r << 16) | (g << 8) | b);
        }
        private static uint Lerp(uint a, uint b, int na, int nb)
        {
            int ar = (int)((a >> 16) & 0xFF), ag = (int)((a >> 8) & 0xFF), ab = (int)(a & 0xFF);
            int br = (int)((b >> 16) & 0xFF), bg = (int)((b >> 8) & 0xFF), bb = (int)(b & 0xFF);
            int r = (na * ar + nb * br) / (na + nb);
            int g = (na * ag + nb * bg) / (na + nb);
            int bl = (na * ab + nb * bb) / (na + nb);
            return (uint)(0xFF000000 | (r << 16) | (g << 8) | bl);
        }

        private static DirectXDDS.PixelFormat BytesToPixelFormat(byte[] b)
        {
            GCHandle h = GCHandle.Alloc(b, GCHandleType.Pinned);
            try { return Marshal.PtrToStructure<DirectXDDS.PixelFormat>(h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
    }

    #endregion
}
